<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clauder Tracer</title>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #001100;
            --bg-tertiary: #002200;
            --bg-quaternary: #000000;
            --text-primary: #ffffff;
            --text-secondary: #00ff00;
            --text-tertiary: #888;
            --text-warning: #ffaa00;
            --text-error: #ff0000;
            --text-success: #00ff00;
            --border-primary: #333;
            --border-secondary: #002200;
            --border-warning: #ffaa00;
            --border-error: #ff0000;
            --button-hover-bg: #00ff00;
            --button-hover-text: #001100;
            --button-disabled-bg: #001100;
            --button-disabled-text: #004400;
            --button-disabled-border: #004400;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', 'Courier New', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.3;
            font-size: 13px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
        }

        .header {
            border-bottom: 1px solid var(--border-primary);
            padding: 8px 0;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: var(--text-secondary);
            font-size: 1.27em;
            font-weight: bold;
            font-family: 'Courier New', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', 'Courier New', monospace;
            margin: 0;
            line-height: 1.1;
        }

        .header .status-info {
            color: var(--text-tertiary);
            font-size: 0.9em;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
            margin-bottom: 15px;
        }

        .stat-card {
            border: 1px solid var(--border-primary);
            padding: 6px 8px;
            background: var(--bg-secondary);
            min-height: 45px;
        }

        .stat-card h3 {
            color: var(--text-secondary);
            font-size: 0.75em;
            margin-bottom: 3px;
            text-transform: uppercase;
            font-weight: normal;
        }

        .stat-card .value {
            font-size: 1em;
            color: var(--text-primary);
            font-weight: bold;
        }

        .timeline-container {
            border: 1px solid var(--border-primary);
            padding: 8px;
            margin-bottom: 15px;
            background: var(--bg-secondary);
        }

        .timeline-header {
            color: var(--text-secondary);
            font-size: 0.75em;
            margin-bottom: 6px;
            text-transform: uppercase;
            font-weight: normal;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', 'Courier New', monospace;
        }

        .timeline-graph {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', 'Courier New', monospace;
            font-size: 0.7em;
            line-height: 1;
            white-space: pre;
            color: var(--text-secondary);
            background: var(--bg-quaternary);
            padding: 4px;
            border: 1px solid var(--border-secondary);
            overflow-x: auto;
            overflow-y: hidden;
            width: 100%;
            min-width: 100%;
            box-sizing: border-box;
            display: block;
            margin: 0;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0;
            word-spacing: 0;
            font-feature-settings: "tnum";
            word-break: keep-all;
            overflow-wrap: normal;
            text-align: left;
        }

        .timeline-graph .event-block {
            color: var(--text-secondary) !important;
        }

        .timeline-graph .decision-block {
            color: var(--text-warning) !important;
        }

        .timeline-graph .error-block {
            color: var(--text-error) !important;
        }

        .timeline-graph .empty-block {
            color: var(--border-primary) !important;
        }

        .timeline-graph span {
            display: inline-block;
            width: 1ch;
            height: 1em;
            text-align: center;
            line-height: 1;
            font-family: inherit;
            min-width: 1ch;
        }

        .timeline-legend {
            display: flex;
            gap: 15px;
            margin-top: 4px;
            font-size: 0.7em;
            color: var(--text-tertiary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 8px;
            height: 8px;
            background: var(--text-secondary);
        }

        .legend-color.event { background: var(--text-secondary); }
        .legend-color.decision { background: var(--text-warning); }
        .legend-color.error { background: var(--text-error); }
        .legend-color.empty { background: var(--border-primary); }

        .controls {
            border: 1px solid var(--border-primary);
            padding: 6px 8px;
            margin-bottom: 15px;
            background: var(--bg-secondary);
            display: flex;
            gap: 8px;
        }

        .controls button {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--text-secondary);
            padding: 4px 8px;
            cursor: pointer;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', 'Courier New', monospace;
            font-size: 0.8em;
            transition: all 0.2s ease;
        }

        .controls button:hover {
            background: var(--button-hover-bg);
            color: var(--button-hover-text);
        }

        .controls button:disabled {
            background: var(--button-disabled-bg);
            color: var(--button-disabled-text);
            border-color: var(--button-disabled-border);
            cursor: not-allowed;
        }

        .events-container {
            border: 1px solid var(--border-primary);
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            height: calc(100vh - 300px);
            min-height: 400px;
        }

        .events-header {
            border-bottom: 1px solid var(--border-primary);
            padding: 6px 8px;
            background: var(--bg-tertiary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .events-header h2 {
            color: var(--text-secondary);
            font-size: 0.9em;
            font-weight: normal;
        }

        .events-header .event-count {
            color: var(--text-tertiary);
            font-size: 0.8em;
        }

        .load-more-link {
            margin-left: 15px;
        }

        .load-more-link a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.8em;
            transition: color 0.2s ease;
        }

        .load-more-link a:hover {
            color: var(--text-primary);
        }

        .load-more-link a:disabled {
            color: var(--button-disabled-text);
            cursor: not-allowed;
        }



        .events-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .event-item {
            padding: 6px 8px;
            border-bottom: 1px solid var(--border-secondary);
            transition: background-color 0.2s ease;
        }

        .event-item:hover {
            background: var(--bg-tertiary);
        }

        .event-item:last-child {
            border-bottom: none;
        }

        .event-item.event-decision {
            border-left: 3px solid var(--border-warning);
        }

        .event-item.event-error {
            border-left: 3px solid var(--border-error);
        }

        .event-item.event-user-prompt {
            border-left: 3px solid var(--text-secondary);
        }

        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 4px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .event-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .event-id {
            color: var(--text-secondary);
            font-weight: bold;
            font-size: 0.8em;
        }

        .event-type {
            background: var(--text-secondary);
            color: var(--bg-secondary);
            padding: 1px 4px;
            font-size: 0.7em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .tool-name {
            color: var(--text-tertiary);
            font-size: 0.7em;
            margin-left: 6px;
            opacity: 0.85;
        }

        .subagent-type {
            color: var(--text-warning);
            font-size: 0.7em;
            opacity: 0.9;
            font-style: italic;
        }

        .event-timestamp {
            color: var(--text-tertiary);
            font-size: 0.75em;
            flex-shrink: 0;
        }

        .event-data {
            background: var(--bg-quaternary);
            padding: 4px 6px;
            font-size: 0.75em;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-secondary);
            color: var(--text-secondary);
            line-height: 1.2;
        }

        .status {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-primary);
            font-size: 0.8em;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', 'Courier New', monospace;
        }

        .status::before {
            content: '●';
            color: var(--text-tertiary);
        }

        .status.connected::before {
            color: var(--text-success);
        }

        .status.disconnected::before {
            color: var(--text-error);
        }



        .loading {
            text-align: center;
            padding: 30px;
            color: var(--text-tertiary);
            font-size: 0.9em;
        }

        .no-events {
            text-align: center;
            padding: 30px;
            color: var(--text-tertiary);
            font-size: 0.9em;
        }

        .new-event {
            animation: highlight 0.8s ease-out;
        }

        @keyframes highlight {
            0% { 
                background: var(--text-secondary);
                color: var(--bg-secondary);
            }
            100% { 
                background: transparent;
                color: var(--text-secondary);
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-primary);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-tertiary);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 8px;
            }
            
            .stats {
                grid-template-columns: 1fr;
                gap: 6px;
            }
            
            .event-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .controls button {
                width: 100%;
            }
        }

        /* Terminal cursor effect */
        .cursor {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Compact table styling */
        .compact-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }

        .compact-table th,
        .compact-table td {
            padding: 2px 4px;
            text-align: left;
            border-bottom: 1px solid #002200;
        }

        .compact-table th {
            color: #00ff00;
            font-weight: normal;
            background: #002200;
        }

        .compact-table td {
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>> clauder.tracer</h1>
            <div class="status-info">
                <span id="connection-status">Connecting...</span> | 
                <span id="table-status">Checking...</span> | 
                bluera.ai
            </div>
        </div>

        <div class="timeline-container">
            <div class="timeline-header">┌─ Recent Activity [Last 15 Minutes from Latest Event] ─┐</div>
            <div class="timeline-graph" id="timeline-graph">Loading timeline...</div>
            <div class="timeline-legend" id="timeline-legend">
                <div class="legend-item">
                    <div class="legend-color event"></div>
                    <span>Event</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color decision"></div>
                    <span>Decision</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color error"></div>
                    <span>Error</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color empty"></div>
                    <span>No Activity</span>
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="clear-btn" onclick="clearEvents()">clear</button>
            <button id="refresh-btn" onclick="loadEvents()">refresh</button>
            <button id="auto-scroll-btn" onclick="toggleAutoScroll()">auto-scroll: ON</button>
        </div>

        <div class="events-container">
            <div class="events-header">
                <h2>[ TRACE EVENTS ]</h2>
                <div class="event-count" id="event-count">0 events</div>
                <div class="load-more-link" id="load-more-container" style="display: none;">
                    <a href="#" id="load-more-btn" onclick="loadMoreEvents(); return false;">+ load more</a>
                </div>
            </div>
            <div class="events-list" id="events-list">
                <div class="loading">Loading events...</div>
            </div>
            <div class="status" id="status">Connecting to event stream...</div>
        </div>
    </div>

    <script>
        let events = [];
        let autoScroll = true;
        let eventSource = null;
        let lastEventId = 0;
        let currentLimit = 100;
        let hasMoreEvents = false;
        let currentSubagentType = null;

        // Theme support
        const themes = {
            green: {
                '--bg-primary': '#0a0a0a',
                '--bg-secondary': '#001100',
                '--bg-tertiary': '#002200',
                '--bg-quaternary': '#000000',
                '--text-primary': '#ffffff',
                '--text-secondary': '#00ff00',
                '--text-tertiary': '#888',
                '--text-success': '#00ff00',
                '--text-error': '#ff0000',
                '--text-warning': '#ffaa00',
                '--border-primary': '#333',
                '--border-secondary': '#002200',
                '--border-warning': '#ffaa00',
                '--border-error': '#ff0000',
                '--button-hover-bg': '#00ff00',
                '--button-hover-text': '#001100',
                '--button-disabled-bg': '#001100',
                '--button-disabled-text': '#004400',
                '--button-disabled-border': '#004400'
            },
            gray: {
                '--bg-primary': '#0a0a0a',
                '--bg-secondary': '#1a1a1a',
                '--bg-tertiary': '#2a2a2a',
                '--bg-quaternary': '#000000',
                '--text-primary': '#ffffff',
                '--text-secondary': '#cccccc',
                '--text-tertiary': '#888',
                '--text-success': '#44ff44',
                '--text-error': '#ff6666',
                '--text-warning': '#ffaa44',
                '--border-primary': '#444',
                '--border-secondary': '#2a2a2a',
                '--border-warning': '#ffaa44',
                '--border-error': '#ff6666',
                '--button-hover-bg': '#cccccc',
                '--button-hover-text': '#1a1a1a',
                '--button-disabled-bg': '#1a1a1a',
                '--button-disabled-text': '#444',
                '--button-disabled-border': '#444'
            },
            blue: {
                '--bg-primary': '#0a0a0a',
                '--bg-secondary': '#001122',
                '--bg-tertiary': '#002244',
                '--bg-quaternary': '#000000',
                '--text-primary': '#ffffff',
                '--text-secondary': '#66aaff',
                '--text-tertiary': '#888',
                '--text-success': '#44ff44',
                '--text-error': '#ff6666',
                '--text-warning': '#ff8844',
                '--border-primary': '#333',
                '--border-secondary': '#002244',
                '--border-warning': '#ff8844',
                '--border-error': '#ff6666',
                '--button-hover-bg': '#66aaff',
                '--button-hover-text': '#001122',
                '--button-disabled-bg': '#001122',
                '--button-disabled-text': '#004400',
                '--button-disabled-border': '#004400'
            },
            dark: {
                '--bg-primary': '#000000',
                '--bg-secondary': '#0a0a0a',
                '--bg-tertiary': '#1a1a1a',
                '--bg-quaternary': '#000000',
                '--text-primary': '#ffffff',
                '--text-secondary': '#aaaaaa',
                '--text-tertiary': '#666',
                '--text-success': '#44ff44',
                '--text-error': '#ff6666',
                '--text-warning': '#ffaa44',
                '--border-primary': '#222',
                '--border-secondary': '#1a1a1a',
                '--border-warning': '#ffaa44',
                '--border-error': '#ff6666',
                '--button-hover-bg': '#aaaaaa',
                '--button-hover-text': '#0a0a0a',
                '--button-disabled-bg': '#0a0a0a',
                '--button-disabled-text': '#333',
                '--button-disabled-border': '#333'
            }
        };

        function applyTheme(themeName) {
            const root = document.documentElement;
            const theme = themes[themeName];
            
            if (theme) {
                Object.entries(theme).forEach(([property, value]) => {
                    root.style.setProperty(property, value);
                });
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Apply theme from localStorage
            const savedTheme = localStorage.getItem('clauder.tracer.theme');
            if (savedTheme && themes[savedTheme]) {
                applyTheme(savedTheme);
            }
            
            loadTimeline();
            loadEvents();
            updateStatusLabels();
            startEventStream();
            
            // Regenerate timeline on window resize
            window.addEventListener('resize', function() {
                setTimeout(loadTimeline, 100); // Small delay to ensure resize is complete
            });
        });

        function loadTimeline() {
            fetch('/api/events?limit=1000')
                .then(response => response.json())
                .then(data => {
                    generateTimeline(data);
                })
                .catch(error => {
                    console.error('Error loading timeline:', error);
                    document.getElementById('timeline-graph').textContent = 'Error loading timeline';
                });
        }

        function updateStatusLabels() {
            fetch('/api/stats')
                .then(response => response.json())
                .then(data => {
                    // Update database status
                    if (!data.db_exists) {
                        document.getElementById('connection-status').textContent = 'No Database';
                        document.getElementById('connection-status').style.color = 'var(--text-error)';
                    } else {
                        document.getElementById('connection-status').textContent = 'Connected';
                        document.getElementById('connection-status').style.color = 'var(--text-success)';
                    }
                    
                    // Update table status
                    if (!data.table_exists) {
                        document.getElementById('table-status').textContent = 'No Table';
                        document.getElementById('table-status').style.color = 'var(--text-warning)';
                    } else {
                        document.getElementById('table-status').textContent = 'Ready';
                        document.getElementById('table-status').style.color = 'var(--text-success)';
                    }
                })
                .catch(error => {
                    console.error('Error loading stats:', error);
                    document.getElementById('connection-status').textContent = 'Offline';
                    document.getElementById('connection-status').style.color = 'var(--text-error)';
                    document.getElementById('table-status').textContent = 'Not Ready';
                    document.getElementById('table-status').style.color = 'var(--text-error)';
                });
        }

        function generateTimeline(events) {
            const now = new Date();
            
            // Find the most recent event time, or use current time if no events
            let lastEventTime = now;
            if (events.length > 0) {
                const timestamps = events.map(e => new Date(e.timestamp));
                lastEventTime = new Date(Math.max(...timestamps));
            }
            
            const fifteenMinutesAgo = new Date(lastEventTime.getTime() - 15 * 60 * 1000);
            
            // Get the container width to determine graph width
            const container = document.querySelector('.timeline-container');
            const containerWidth = container ? container.offsetWidth - 32 : 800; // Account for padding and borders
            const charWidth = 6; // More accurate width for the font size
            const graphWidth = Math.floor(containerWidth / charWidth); // Use full available width
            

            

            
            // Create timeline array based on available width
            const timeline = new Array(graphWidth).fill(null);
            
            // Process events and map them to timeline
            let mappedEvents = 0;
            let timelineEvents = [];
            
            events.forEach(event => {
                const eventTime = new Date(event.timestamp);
                

                
                if (eventTime >= fifteenMinutesAgo && eventTime <= lastEventTime) {
                    const minutesAgo = (lastEventTime - eventTime) / (1000 * 60); // Use floating point for precision
                    // Map time to index: graphWidth-1 = oldest (left), 0 = newest (right) - RIGHT TO LEFT
                    const timeRatio = minutesAgo / 15; // 0 to 1 ratio
                    const index = graphWidth - 1 - Math.floor(timeRatio * (graphWidth - 1)); // Right to left mapping
                    
                    // Ensure index is within bounds
                    const clampedIndex = Math.max(0, Math.min(graphWidth - 1, index));
                    
                    if (clampedIndex >= 0 && clampedIndex < graphWidth) {
                        // Determine event type based on operation_type and data content
                        let eventType = 'event';
                        
                        // Check if it's an error first (contains 'continue: false')
                        if (event.data && typeof event.data === 'object' && event.data.continue === false) {
                            eventType = 'error';
                        }
                        // Check if data is a string and contains 'continue: false'
                        else if (event.data && typeof event.data === 'string' && event.data.toLowerCase().includes('continue: false')) {
                            eventType = 'error';
                        }
                        // Check if it's a decision (case insensitive)
                        else if (event.operation_type && event.operation_type.toLowerCase().includes('decision')) {
                            eventType = 'decision';
                        }
                        
                        // If there's already an event at this index, prioritize decision/error over regular events
                        if (timeline[clampedIndex] && timeline[clampedIndex] !== 'event') {
                            // Keep the existing event (decision/error takes priority)
                        } else {
                            timeline[clampedIndex] = eventType;
                        }
                        mappedEvents++;
                        

                    }
                }
            });
            
            // Generate character art timeline
            const graphHeight = 8;
            let graph = '';
            

            
            // Add time labels with hours
            const timeLabels = [];
            const labelCount = Math.min(8, Math.floor(graphWidth / 8)); // More labels for better coverage
            for (let i = 0; i < labelCount; i++) {
                const minutesAgo = i * (15 / labelCount);
                const time = new Date(lastEventTime.getTime() - minutesAgo * 60 * 1000);
                const hours = time.getHours().toString().padStart(2, '0');
                const minutes = time.getMinutes().toString().padStart(2, '0');
                timeLabels.push(`${hours}:${minutes}`);
            }
            const labelSpacing = Math.floor(graphWidth / labelCount);
            const timeLabelLine = timeLabels.reverse().map((label, i) => 
                label.padStart(labelSpacing, ' ')
            ).join('');
            graph += timeLabelLine + '<br>';
            

            
            // Generate timeline rows
            for (let row = 0; row < graphHeight; row++) {
                let line = '';
                for (let col = 0; col < graphWidth; col++) {
                    const event = timeline[col];
                    if (event === 'event') {
                        line += '<span class="event-block">█</span>';
                    } else if (event === 'decision') {
                        line += '<span class="decision-block">█</span>';
                    } else if (event === 'error') {
                        line += '<span class="error-block">█</span>';
                    } else {
                        line += '<span class="empty-block">·</span>';
                    }
                }
                graph += line + '<br>';
            }
            

            
            document.getElementById('timeline-graph').innerHTML = graph;
            

        }

        function loadEvents() {
            fetch(`/api/events?limit=${currentLimit}`)
                .then(response => response.json())
                .then(data => {
                    events = data;
                    renderEvents();
                    if (data.length > 0) {
                        lastEventId = Math.max(...data.map(e => e.id));
                    }
                    // Check if there are more events available
                    checkForMoreEvents();
                })
                .catch(error => {
                    console.error('Error loading events:', error);
                    document.getElementById('events-list').innerHTML = 
                        '<div class="no-events">Error loading events</div>';
                });
        }

        function startEventStream() {
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource('/api/stream');
            
            eventSource.onopen = function() {
                document.getElementById('status').textContent = 'Connected to live stream';
                document.getElementById('status').className = 'status connected';
            };

            eventSource.onmessage = function(event) {
                const newEvent = JSON.parse(event.data);
                
                // Handle status and error messages
                if (newEvent.type === 'status' || newEvent.type === 'error') {
                    // Update status display
                    const statusElement = document.getElementById('status');
                    statusElement.textContent = newEvent.message;
                    statusElement.className = `status ${newEvent.type}`;
                    
                    // Refresh timeline and status labels
                    loadTimeline();
                    updateStatusLabels();
                    return;
                }
                
                // Handle regular events
                events.unshift(newEvent);
                
                // Keep only last 100 events
                if (events.length > 100) {
                    events = events.slice(0, 100);
                }
                
                renderEvents();
                loadTimeline(); // Update timeline with new data
                updateStatusLabels(); // Update status labels
                
                // Highlight new event
                const firstEvent = document.querySelector('.event-item');
                if (firstEvent) {
                    firstEvent.classList.add('new-event');
                    setTimeout(() => firstEvent.classList.remove('new-event'), 800);
                }
            };

            eventSource.onerror = function() {
                document.getElementById('status').textContent = 'Connection lost. Reconnecting...';
                document.getElementById('status').className = 'status disconnected';
                setTimeout(startEventStream, 5000);
            };
        }

        function renderEvents() {
            const container = document.getElementById('events-list');
            const countElement = document.getElementById('event-count');
            
            if (events.length === 0) {
                container.innerHTML = '<div class="no-events">No events found</div>';
                countElement.textContent = '0 events';
                return;
            }

            countElement.textContent = `Last ${events.length} events`;

            // Process events in chronological order (oldest to newest) to establish context
            const eventsInOrder = [...events].reverse();
            let subagentContext = null;
            
            // First pass: establish subagent context for each event
            const eventsWithContext = eventsInOrder.map(event => {
                // Extract tool name and subagent type for PreToolUse and PostToolUse events
                let toolName = '';
                let subagentType = null;
                if ((event.operation_type === 'PreToolUse' || event.operation_type === 'PostToolUse') && event.data) {
                    try {
                        const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
                        if (data && data.tool_name) {
                            toolName = data.tool_name;
                        } else if (data && data.name) {
                            toolName = data.name;
                        }
                        
                        // Extract subagent type for Task tools
                        if (toolName === 'Task' && data && data.tool_input && data.tool_input.subagent_type) {
                            subagentType = data.tool_input.subagent_type;
                        }
                    } catch (e) {
                        // If parsing fails, try to extract tool name from string
                        const dataStr = typeof event.data === 'string' ? event.data : JSON.stringify(event.data);
                        const toolMatch = dataStr.match(/"tool_name"\s*:\s*"([^"]+)"/);
                        if (toolMatch) {
                            toolName = toolMatch[1];
                        }
                        
                        // Try to extract subagent type from string
                        const subagentMatch = dataStr.match(/"subagent_type"\s*:\s*"([^"]+)"/);
                        if (toolName === 'Task' && subagentMatch) {
                            subagentType = subagentMatch[1];
                        }
                    }
                }
                
                // Update subagent context based on event
                if (event.operation_type === 'PreToolUse' && toolName === 'Task' && subagentType) {
                    subagentContext = subagentType;
                } else if (event.operation_type === 'PostToolUse' && toolName === 'Task' && subagentType) {
                    subagentContext = null;
                } else if (event.operation_type === 'Stop' || event.operation_type === 'UserPromptSubmit') {
                    subagentContext = null;
                } else if (event.data && typeof event.data === 'object' && event.data.continue === false) {
                    subagentContext = null;
                } else if (event.data && typeof event.data === 'string' && event.data.toLowerCase().includes('continue: false')) {
                    subagentContext = null;
                }
                
                return {
                    ...event,
                    displaySubagentType: subagentContext
                };
            });
            
            // Reverse back to newest-first for display
            const eventsForDisplay = eventsWithContext.reverse();

            container.innerHTML = eventsForDisplay.map(event => {
                // Determine event type for styling
                let eventClass = '';
                if (event.data && typeof event.data === 'object' && event.data.continue === false) {
                    eventClass = 'event-error';
                } else if (event.data && typeof event.data === 'string' && event.data.toLowerCase().includes('continue: false')) {
                    eventClass = 'event-error';
                } else if (event.operation_type && event.operation_type.toLowerCase().includes('decision')) {
                    eventClass = 'event-decision';
                } else if (event.operation_type === 'UserPromptSubmit') {
                    eventClass = 'event-user-prompt';
                }
                
                // Extract tool name for PreToolUse and PostToolUse events
                let toolName = '';
                if ((event.operation_type === 'PreToolUse' || event.operation_type === 'PostToolUse') && event.data) {
                    try {
                        const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
                        if (data && data.tool_name) {
                            toolName = data.tool_name;
                        } else if (data && data.name) {
                            toolName = data.name;
                        }
                    } catch (e) {
                        // If parsing fails, try to extract tool name from string
                        const dataStr = typeof event.data === 'string' ? event.data : JSON.stringify(event.data);
                        const toolMatch = dataStr.match(/"tool_name"\s*:\s*"([^"]+)"/);
                        if (toolMatch) {
                            toolName = toolMatch[1];
                        }
                    }
                }
                
                return `
                <div class="event-item ${eventClass}">
                    <div class="event-header">
                        <div class="event-left">
                            <span class="event-id">#${event.id}</span>
                            ${event.displaySubagentType ? `<span class="subagent-type">[${event.displaySubagentType}]</span>` : ''}
                            <span class="event-type">${event.operation_type}</span>
                            ${toolName ? `<span class="tool-name">${toolName}</span>` : ''}
                        </div>
                        <span class="event-timestamp">${event.timestamp}</span>
                    </div>
                    <div class="event-data">${JSON.stringify(event.data, null, 2)}</div>
                </div>
            `;
            }).join('');

            if (autoScroll) {
                container.scrollTop = 0;
            }
        }

        function clearEvents() {
            events = [];
            renderEvents();
        }

        function checkForMoreEvents() {
            // Check if there are more events by requesting one more than current limit
            fetch(`/api/events?limit=${currentLimit + 1}`)
                .then(response => response.json())
                .then(data => {
                    hasMoreEvents = data.length > currentLimit;
                    const loadMoreContainer = document.getElementById('load-more-container');
                    if (hasMoreEvents) {
                        loadMoreContainer.style.display = 'block';
                    } else {
                        loadMoreContainer.style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Error checking for more events:', error);
                });
        }

        function loadMoreEvents() {
            const link = document.getElementById('load-more-btn');
            link.style.pointerEvents = 'none';
            link.textContent = 'Loading...';
            
            currentLimit += 100;
            
            fetch(`/api/events?limit=${currentLimit}`)
                .then(response => response.json())
                .then(data => {
                    events = data;
                    renderEvents();
                    if (data.length > 0) {
                        lastEventId = Math.max(...data.map(e => e.id));
                    }
                    checkForMoreEvents();
                    
                    link.style.pointerEvents = 'auto';
                    link.textContent = '+ load more';
                })
                .catch(error => {
                    console.error('Error loading more events:', error);
                    link.style.pointerEvents = 'auto';
                    link.textContent = '+ load more';
                });
        }

        function toggleAutoScroll() {
            autoScroll = !autoScroll;
            const btn = document.getElementById('auto-scroll-btn');
            btn.textContent = `auto-scroll: ${autoScroll ? 'ON' : 'OFF'}`;
        }

        // Refresh timeline and status labels every 10 seconds
        setInterval(() => {
            loadTimeline();
            updateStatusLabels();
        }, 10000);
    </script>
</body>
</html> 